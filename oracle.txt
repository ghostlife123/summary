常用函数
	单行函数:只处理单个行,并且为每行返回一个结果
		1.字符函数
			1)LPAD函数: 左边对字符串使用指定的字符进行填充
				lpad(string,padded_length,[pad_string])
					string 	准备被填充的字符
					padded_length	填充之后的字符串长度,该函数返回的字符串长度
									如果比原来的长度要段,则会把字符串截取成从左到右的n个字符
					pad_string		填充字符,如果未写,则将string左边黏贴空格
			
			2)NVL函数	
				NVL(string,replace_with),则返回replace_with,不为null则返回string
					都为null则返回null  string和replace_with类型一致
				NVL2(x,value1,value2) 如果x不为null返回value1,否则返回value2
			
			3)concat函数
				CONCAT(str1,str2)字符串拼接 等价于 || 
				select concat('Hello','world') from dual;
				select 'Hello' || 'World' from dual;
			
			4)initcap(str) 将每个单词首字母大写,其他字母小写
				select initcap('hello world') from dual ----返回Hello World
				select initcap('HELLO WORLD') from dual ----返回Hello World
			
			5)instr(x,find_string[,start][,occurrence])
				返回指定字符串在某字符串中的位置,
				可以指定搜索的开始位置和返回第几次搜索出来的结果
			
			6)trim,ltrim,rtrim			
				ltrim(x[,trim_string])	从左侧去除指定字符串
								
				rtrim(x[,trim_string])	从右侧去除指定字符串
										
				trim(trim_string from x)从字符串两侧去除指定所有字符串
				
			7)replace(x,search_string,replace_string)
				从字符串x中搜索search_string字符串,并且使用replace_string字符串替换
				并不会修改数据库中原始值
			
			8)substr(x,start[,length])返回字符串中的指定字符,
				这些字符从字符串的第start位置开始,长度为length个字符;
				如果start是负数,则从x字符串的末尾开始算起
				如果length省略,则返回一直到字符串末尾的所有字符
		2.数值函数
		3.格式化函数
			https://www.cnblogs.com/aipan/p/8080151.html
			http://www.jb51.net/article/53639.htm
			to_data,
			to_char,
				extract(): 
					从一个日期里面截取year,month,day(data的格式为yyyy-MM-dd)
						extract(minute from date'yyyy-MM-dd')
					获取两个日期之间的时间间隔
						extract(minute from date1-date2)
					
			to_number
		4.日期函数
			
	聚集函数:
		1.常用函数
		2.对分组使用聚集函数
		3.


union all

decode函数
	decode(条件,值1,返回值1,值2,返回值2...,"缺省值 可以省略");
	decode(字段或者字段运算,值1,值2,值3)
		字段或者运算==值1时 返回值2 否则返回值3	值1 值2 值三可以为表达式
sign()函数	根据某个值是0还是正数 负数 返回0 1 -1
	判断2个值的大小 返回小值
		select decode(sign(变量1-变量2),-1,变量1,变量2)
	decode+lpad函数实现主键自增 并在前面补0
递归函数
	
	start with 条件 connect by (nocycle) prior id=parent_id 向下递归
	start with 条件 connect by (nocycle) prior parent_id=id 向上递归
	后面可以加where条件 但是条件实是在递归结束后执行 
	connect_by_root(列名)	查询根节点
	connect_by_isleaf		查询是否叶子节点 0是 1不是
	sys_connect_by_path(name,'符号0000')		查询递归路径
		注意不能使用逗号,如果要使用,需要用replace处理
		使用该函数必创建一个树 否则无用
	nocycle 关键字忽略掉
instr()函数和like关键字的区别
	instr()用法:
		instr(name,'aaa')>0		相当于 name like '%aaa%'
		instr(name,'aaa')=1		相当于 name like 'aaa%'
		instr(name,'aaa')<0		相当于 name not like '%aaa%'
	在数据量很大是 使用instr()函数的查询效率比使用like高很多,oracle中的函数是做过一些优化的
	所以,建议使用函数去执行操作,instr()代替like是常用用法之一
	其他还有
		instr(sourceString,destString,startIndex,apperPosition)		返回查找到的字符串的index
				startIndex	可以为负 表示从右边开始查询,但返回index依然从左边计算
				apperPosition 默认为1 可以指定;
	
	WMSYS.WM.CONCAT 可以用来拼接列,排序是不规则的,							 11g不能用了 似乎 
	listagg(T.ENAME,',')  within group (order by T.EMPNO) CONCAT FROM EMP T	 建议使用这个做列转行 
	wmsys.wm.concat(name)
OVER() 			分析函数
row_number()    分析函数

触发器和级联操作的区别
	触发器的可以实现hibernate的级联操作, 但效率比级联操作低
	触发器的作用在于控制:	操作灵活
		
视图	
	强大之处它能够根据不同用户的需要来对基表中的数据进行整理
	with read only
	本质上是一条sql语句,不占用物理空间,查视图相当于 重新执行sql语句,视图可以从另外一个视图中产生
	当修改视图中的数据时,相当于修改基表中的数据,基表中的数据改动,也会自动反应在视图中,但由于逻辑上
	的原因,有些oracle视图可以修改对应的基表,有些则不能(仅仅是查询).
		
	物化视图(MATERIALIZED VIEW)
		实体化视图,占用存贮空间,含有数据
	视图作用:(提高查询效率,保护数据)
		提供各种数据的表现形式,
		隐藏数据的逻辑复杂性,简化查询语句,
		保护某些敏感列数据,让不同的用户看到不同的列
		执行某些必须使用视图的查询
		
	创建视图:
		create [ or replace ] [ force ] view view_name
		[ (column1,column2,...) ]	as
		select ...
		[ with check option ]
		[ constraint constraint_name ]
		[ with read only ]
		
		force::"强制"创建视图,不考虑基表是否存在,也不考虑是否具有基表的使用权限
		with check option:指定对视图执行dml操作时满足"视图子查询"
			视图子查询:对通过视图进行增删改操作进行"检查",要求增删改数据,必须是select查询所能查询到的数据
				否则不允许并返回错误提示,默认情况下,在增删改之前"不会检查"这些行是否能被select查询检索到
		with read only:视图为只读模式,不能用于更改数据
		
	连接视图的更新准则
		dml操作只能对视图键值保存标进行更新
		只能使用连接视图定义过的列
		"自连接视图"的所有列都是可更新的
		insert操作的视图至少"包含"键值保存表中所设置了约束的列

存贮过程

存贮函数		
		
		
oracle使用
	https://www.cnblogs.com/adforce/p/3312252.html
	http://blog.csdn.net/u013412772/article/details/52733050
	select * from dba_users		查询数据库用户
	sqlplus  "sys/密码@数据库服务名 as sysdba"这样写在cmd中就可以以DBA身份登陆了

	表空间(tablespace):oracle通过表空间来存储物理表,
	一个数据库实例可以有N个表空间,一个表空间可以有N张表
	创建的用户必须指定表空间,一个用户只能指定一个表空间

	数据库中文乱码
		设置环境变量名：NLS_LANG，变量值：SIMPLIFIED CHINESE_CHINA.ZHS16GBK
	
	
	
		
		
	

http://blog.csdn.net/u013120247/article/details/51542988


mysql
	mysql 自增原理是 等insert语句执行完毕后 再将主键生成
